<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>


<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Question 5: Googleplay" />




<meta name="author" content="Grace Grant" />


<meta name="description" content="Question 5: Googleplay">

<script id="pandoc-meta" type="application/json">
{"newpage_html_class":"page-break-after","bibliography":"Tex/ref.bib","date":"June 2023","csl":"Template/harvard-stellenbosch-university.csl","output":{"pagedown::html_paged":{"self_contained":true,"toc":false,"css":["Template/default-fonts-Texevier.css","Template/default-page-Texevier.css","Template/default-Texevier.css"],"csl":"Template/harvard-stellenbosch-university.csl","template":["Template/paged-Texevier.html"]}},"author":"Grace Grant","title":"Question 5: Googleplay"}
</script>

<title>Question 5: Googleplay</title>


<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">@font-face {
font-family: 'Old Standard TT';
font-style: normal;
font-weight: 400;
src: url(data:font/ttf;base64,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IC5HI0cjYSBgsCBgZrACYiCwAFBYsEBgWWawAWMjICA8ijgtsD4sIyAuRrACJUawEENYUBtSWVggPFkusS4BFCstsD8sIyAuRrACJUawEENYUhtQWVggPFkusS4BFCstsEAsIyAuRrACJUawEENYUBtSWVggPFkjIC5GsAIlRrAQQ1hSG1BZWCA8WS6xLgEUKy2wQSywOCsjIC5GsAIlRrAQQ1hQG1JZWCA8WS6xLgEUKy2wQiywOSuKICA8sAQjQoo4IyAuRrACJUawEENYUBtSWVggPFkusS4BFCuwBEMusC4rLbBDLLAAFrAEJbAEJiAuRyNHI2GwCUMrIyA8IC4jOLEuARQrLbBELLEIBCVCsAAWsAQlsAQlIC5HI0cjYSCwBCNCsAlDKyCwYFBYILBAUVizAiADIBuzAiYDGllCQiMgR7AEQ7ACYiCwAFBYsEBgWWawAWNgILABKyCKimEgsAJDYGQjsANDYWRQWLACQ2EbsANDYFmwAyWwAmIgsABQWLBAYFlmsAFjYbACJUZhOCMgPCM4GyEgIEYjR7ABKyNhOCFZsS4BFCstsEUssQA4Ky6xLgEUKy2wRiyxADkrISMgIDywBCNCIzixLgEUK7AEQy6wListsEcssAAVIEewACNCsgABARUUEy6wNCotsEgssAAVIEewACNCsgABARUUEy6wNCotsEkssQABFBOwNSotsEossDcqLbBLLLAAFkUjIC4gRoojYTixLgEUKy2wTCywCCNCsEsrLbBNLLIAAEQrLbBOLLIAAUQrLbBPLLIBAEQrLbBQLLIBAUQrLbBRLLIAAEUrLbBSLLIAAUUrLbBTLLIBAEUrLbBULLIBAUUrLbBVLLMAAABBKy2wViyzAAEAQSstsFcsswEAAEErLbBYLLMBAQBBKy2wWSyzAAABQSstsFosswABAUErLbBbLLMBAAFBKy2wXCyzAQEBQSstsF0ssgAAQystsF4ssgABQystsF8ssgEAQystsGAssgEBQystsGEssgAARistsGIssgABRistsGMssgEARistsGQssgEBRistsGUsswAAAEIrLbBmLLMAAQBCKy2wZyyzAQAAQistsGgsswEBAEIrLbBpLLMAAAFCKy2waiyzAAEBQistsGssswEAAUIrLbBsLLMBAQFCKy2wbSyxADorLrEuARQrLbBuLLEAOiuw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) format('truetype');
}
body {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'source-han-serif-sc', 'Source Han Serif SC', 'Source Han Serif CN', 'Source Han Serif TC', 'Source Han Serif TW', 'Source Han Serif', 'Songti SC', 'Microsoft YaHei', serif;
}
blockquote {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'STKaiti', 'KaiTi', '楷体', 'SimKai', 'DFKai-SB', 'NSimSun', serif;
}
code {
font-family: Consolas, Courier, "Courier New", 'STKaiti', 'KaiTi', 'SimKai', monospace;
}
pre, code {
font-size: .95em;
}
</style>
<style type="text/css">
@page {
size: 6in 9in; 
}
@page :blank {
}

.shorttitle1 {
string-set: h1-text content(text);
}
.shorttitle2 {
string-set: h2-text content(text);
}

.running-h1-title {
position: running(runningH1Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h1-title:before {
content: string(h1-text);
}
@page chapter:left {
@top-left {
content: counter(page);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}

.running-h2-title {
position: running(runningH2Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h2-title:before {



content: string(h2-text);
}
@page chapter:right {
@top-right {
content: counter(page);
}
@top-left {
content: element(runningH2Title);
white-space: nowrap !important;
}
}

@page chapter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page);
}
}
@page :first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: none !important;
}
background-image: var(--front-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.front-cover {
break-after: recto;
}

.front-page {
counter-reset: page 1;
}

@page frontmatter:left {
@top-left {
content: counter(page, lower-roman);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:left {
@top-right {
content: counter(page, lower-roman);
}
@top-left {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page, lower-roman);
}
}

.back-cover {
break-before: verso;
}
.pagedjs_page:nth-last-of-type(1) {
background-image: var(--back-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.level1 {
break-before: avoid;
page: chapter;
}
.front-matter-container .level1 {
page: frontmatter;
}
.section > h1, .section > h2, .section > h3, .section > h4, .section > h5, .section > h6 {
break-before: avoid;
break-after: avoid;
}
.footenotes {
break-before: always;
break-after: always;
}
.figure {
break-inside: avoid;
}

.main .level1:first-child h1 {
counter-reset: page 1;
}

caption {
break-inside: avoid;
break-after: avoid;
}
</style>
<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}
.abstract {
border-width: 0.5px 0;
border-style: solid;
margin-top: 0px;
margin-bottom: 2px;
font-size: 12px;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

h1 {
font-weight: bold;
font-size: 23px;
}
h2 {
font-weight: bold;
font-size: 20px;
}
p {
font-size: 12px;
}
.sourceCode {
font-size: 10px;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: hidden;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
font-size: 11px;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Question 5: Googleplay</h1>
<h5 class="author">Grace Grant</h5>
<h5 class="date">June 2023</h5>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<div id="app-size-and-ratings-linked-to-number-of-installs" class="section level1" number="1">
<h1><span class="header-section-number">1</span> App size and ratings linked to number of installs</h1>
<p><img src="data:image/png;base64,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fPnLX8YxxxwzYllaKQIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiML0ESkoAXbdunUfz2GOP9aw0c6Fdvnx5rsUHLHv88cfx7W9/G+FwGJ/5zGfw0pe+FKlUCr/97W+95R/+8Idx4403orm5+YB9tUAEREAEREAEREAEREAEREAEREAEREAEREAERKAwCJSkAGpT1M8555yDIvyTn/wE6XQab3nLW/Av//IvXl6hUAjnnXcetm/f7lmamhj6rne9a9zl7NixY9z7zvQdA4EAZs2ahba2Ns8yd6bzKPb2m4V1VVWV14yOjg7EYrFib9KMr395eTlqamqg81xpHAr19fWIRCJeY1paWuC6bmk0bAa3wn6fwWDQu47OYAwl03R7IO/z+byH9a2trSXTrpnckKamJu9+qKenZyZjKIm22xiysbHRa4u5bOvq6prUdmXvwSa1EGUuAiIgAkVIoKSCINkUeEsrVqw4qK6wC9P999/v5XHmmWcekFd22R/+8AfvRvOADbRABERABERABERABERABERABERABERABERABESgIAiUjABq09M3btzoWTNkAxR1d3cjHo+PGfTTTz/tWX8uWLAAc+fOPWD/lStXetZq9vRu8+bNB6zXAhEQAREQAREQAREQAREQAREQAREQAREQAREQgcIgUDJT4C1KezKZxMKFCz3fnL/5zW+8aV1+v99bdv755+OMM87Ii/q2bdu87Wpra4fd3tbZlJQtW7YMGxH+jjvu8AIm5crEpm9/+tOfzrVKy/IgYNO8LNm0aU3FzANYgW9iLg2yqaKiAmVlZdmvei9SAtk+raurK9IWqNqDCdhU6WyyqdNKxU/ApmTatVS/0eLvy8EtsHOv+nQwkeL9bGOYaDTqGXcUbytUcyOQHbfYZ3MnM9m/UTMMUhIBERABETiQwL4RzYHrimpJNgCSWWRee+21np8VC4a0adMm7/W5z33Oi+D+8Y9/fNR29fX1eduMJIBWV1d722S3zZWpiaN/+9vfcq2CWZfaTY3SwRGwIFVKpUVAfVpa/anzXGn1p7VGfVpafar+LK3+NKFFfVo6fWoi6OAHUKXTspnbEntIkX1IPFkUzJ2bkgiIgAiIwIEESkYAzfr/NIvAL37xizjqqKO81logI7MG/da3voVbb70VJ5xwAk455ZQDSQxakr1oZIOyDFq196MFbbGkYC17keiDCIiACIiACIiACIiACIiACIiACIiACIiACBQcgZIRQC+44AKcfvrpXtThwX477Un461//es8K1ITQ66+/flQB1KbgWkokEsN2WNa3aDYqbq4Nzz33XFhE+lzJnubu2rUr1yoty4OAPTltaGiARQw31wdKxU3AolVmHyqYb93s76u4WzWza29uDOwhks5zpXEc2IyIrHX27t275XqkBLrVfp92Le3s7CyB1qgJFjHc7nkdx/FcQIlI8ROor6/37odGmm1W/K2cGS2wcZ/1pyUznrE4FZOZRhqfTma5ylsEREAECp1AyQigdiO/atWqYXm/7GUv8yxBn3vuOW/gZlNKhkuNjY3eqpEuTub/01JWLPW+7PfH6mSv4dKOHTuGW6XleRIw/592s69U3ATMUjub1KdZEsX9nvXNq99ncfdjtvaDf6PWp9n+za7Xe/ERyPapfqPF13cj1dj6VX06EqHiWqf+LK7+Gq62g8edus8djpKWi4AIiMDkExheBZz8sqe0hNmzZ3vlmVXnaE9SswJoVuTMVdGsODrZTqxzla1lIiACIiACIiACIiACIiACIiACIiACIiACIiAC+REoGQvQW265xZvy84pXvAKLFy8+oPUtLS3eMgteNJJVpm1kEdotWRAjm15tkVIHJ5ui297eDnuat3z58sGr9FkEREAEREAEREAEREAEREAEREAEREAEREAERKCACJSMBegdd9yBG264AT/5yU9y4r3rrru85atXr865fvBC8yG6cuVK9Pb24r777hu8yvv817/+1ZteZNuY70IlERABERABERABERABERABERABERABERABERCBwiRQMgLoqaee6hG+8847sWHDhiG0H3roIZiFqKWLLrpoyLq7774bt99+O8w36OD0pje9yft63XXXYfBUeAvocdNNN3nrzjvvvMG76LMIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiECBESiZKfAmRt5zzz145JFHcOGFF+LYY4/1XuvXr4dZbFq69NJLsWLFiiFdcMUVV8CCEV188cVYsmTJ3nUnn3yyF1Tp6aefxjve8Q6YwJpKpWCWpm1tbXjJS14ybIT3vZnogwiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIwLQSKBkBNBAI4Ktf/ao3Df7GG2+EWX3ay9KCBQvwvve9DyeccELesC2/K6+8Epdffjn+/Oc/e/nazrb83HPPxSWXXOL5AM07Q20oAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIw5QR8aaYpL3WSCzRLze3bt6OzsxNLly5FZWXlQZVo+dm0ekNlYmpFRcVB5Zfd2SxPlcZHwIRoC1Zl1riJRGJ8mWivgiFgv9FscLKOjg7EYrGCqZsqMj4C5h+5pqbGs7AfXw7aq5AI1NfXIxKJeFWyoIKu6xZS9VSXcRCw32cwGPSuo+PYXbsUGIHm5mb4fD5vtlJra2uB1U7VGQ+BpqYm735osCuu8eSjfaafgAXUbWxs9CrS398PC6g7mSl7DzaZZShvERABEShGAiVjAToYvt3QL1y40HsNXj7ez5bf/lPnx5uX9hMBERABERABERABERABERABERABERABERABEZg6AiUTBGnqkKkkERABERABERABERABERABERABERABERABERCBYiEgAbRYekr1FAEREAEREAEREAEREAEREAEREAEREAEREAERGDMBCaBjRqYdREAEREAEREAEREAEREAEREAEREAEREAEREAEioWABNBi6SnVUwREQAREQAREQAREQAREQAREQAREQAREQAREYMwEJICOGZl2EAEREAEREAEREAEREAEREAEREAEREAEREAERKBYCEkCLpadUTxEQAREQAREQAREQAREQAREQAREQAREQAREQgTETkAA6ZmTaQQREQAREQAREQAREQAREQAREQAREQAREQAREoFgISAAtlp5SPUVABERABERABERABERABERABERABERABERABMZMQALomJFpBxEQAREQAREQAREQAREQAREQAREQAREQAREQgWIhIAG0WHpK9RQBERABERABERABERABERABERABERABERABERgzAQmgY0amHURABERABERABERABERABERABERABERABERABIqFgATQYukp1VMEREAEREAEREAEREAEREAEREAEREAEREAERGDMBCSAjhmZdhABERABERABERABERABERABERABERABERABESgWAhJAi6WnVE8REAEREAEREAEREAEREAEREAEREAEREAEREIExE5AAOmZk2kEEREAEREAEREAEREAEREAEREAEREAEREAERKBYCEgALZaeUj1FQAREQAREQAREQAREQAREQAREQAREQAREQATGTEAC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PuVXW201ownwt51iUMsAH5lMVgrwQb3LWUkV6fHNSJqseilfERABERABERCB6SUwjDwwvZVS6YVHwPXVcJBqw9RhxM89Vbb1PrOvG+PA1Sx+HA7aggzgYKmPwWOyQpKfA+vM56HioW03NGVELZ/LffnRvnX1jm6JNDSPif/mS1MUoxh7oNUsy+JixkOmT9UQ/rypbeILn4E59gxQQmHn++2wGSU5nIa7uZ0+bCcq0ZqNP4BRU8YKNM0ATRNY9qilagMRmDwCaU5hT5uyv8flw0glpelGxaa7+7htrp+LWWhbSnK7NU9KqBuJZXZde6KPAQBjtPwsyy7K+R7l1OCYG0NrbAKf/OQsSQtFIDcBezhtlt90BpN7gwlYanmb//jgfg+dJyBrZSECIiACIiACIlDEBCSAFnHnTWnV87DqydQnM/X4wGnqI9fWxs2evGpzo5gCe4RQ74u3zJbnGip7Wwz94x3VNrC2qZh57jM0h4n9RstYm5KfkWRzZO0NBtKoCk+/tWqO2hXdomAg0+d56DCetbH5B524xLzyKXhPgb5JtICZuDYpJxHIg4DnnoTHfx6n3KA9EOLvZORfnj1KA2qrdZuSB32EPEHJgr6NLCqZBagXGsnzp51PztpGBCaYAIOjWXy03I8/JrIsnmMK4R5wIpukvERABERABERABA6KgEYWB4Vv5uwcDHXyRjJj3TlSqzNDVoYu4tTusaSAm/QCH6U8H3LgVHjz48nbY968pugfLiOojjxczpTnImV+pbybXhfL503/IZ72xWndGqOom8PnI6frW1Ap1x/DOw5fOBZk2nYYAg2VSa/7HU6DHy7R8JOJPkKDPixtmjg/g2bRlknDl23rba0d22e/sD2zuf6KQJETCFJYs+M/E2Zs5MaEgilE05nprylaae2fkpwia+f8KP34LVwwskXj/vvO1O/zy+tR7qtAT5rBCodJDsXRgXQvquhfdVFVzTBbabEITC4BXzrFayADaeb47U9UyS7vJc2DfMKbQTRRuSofERABERABERCBYicw/epQsROcIfW/6o3LOKe432utz6K950x7lgdi+NALm3JuMdzC8ugARc8EEoEoxcIA5tCaJcDpfDZVuNydzxnk2answx2ytpw2pAy+EU5lBnYBXxIXnTa6P7rh6jRRyxdFy5EKMpCTU08RtGJPtvRP6UYY8KOZbW5D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XAl0JptgDymyg7fe3t5Jt14pDWqF3YrsgFy/0cLup3xrlxVAzbJMfZovtcLezq6hJn6qPwu7n/KpnV1D7b7Ikj3on+w+zZaVT920jQiIgAjMJALyATqTelttFQEREAEREAEREAEREAEREAEREAEREAEREIEZRkAWoDOsw9VcERCB6SWwuxu486lqbNwdQU/Mz+lt5obZpkalURV1sbQxjtMO60Zj9fTWU6WLgAiIwFgIXPvtTegJNmDAX46EL4Q0XdX40y4ibhyVbi/qwm1488XLx5KlthUBERABERABERABERCBCSMgAXTCUCojERABERiewKPPh/C7h2rR1heg6Amk4dtvYx/ae/zY3BrAXevK0VDh4DXHduKoRcn9ttNXERABESgMAvff9TzufqwGu8PN6C8/Eo4vSOHTz/NbNvngowjqh4tgejGevaYPcxPbcMl7m7Mb6F0EREAEREAEREAEREAEpoSABNApwaxCREAEZiqBfuqX37mtAVvaw0gx2DKNojxxgLF6+cX7vxeNiQbptM/bbmdXED/8WwMW1Cfx/jPbEAnt3UwfREAERGDaCXzvim3YXL4SffRT6NDi01IgnULATfLUZo940t5fl59cfwBxfxkS/gi6A5X47DU9eEF0E869YOG0t0MVEAEREAEREAEREAERmBkE5AN0ZvSzWikCIjANBLZ3hvDZX83CptYQHDcjdpooEAykGSGdYgHPwAwMuvdl321dRjwA9/F5+/6/XzXD8lISAREQgUIg8M2re7G+YpUnZroUP8NOHGVOP8JugpaeFEHTjjf93d5D/B6x9ak+TxxNBqJoC9bjgcRKXPPtrYXQHNVBBERABERABERABERgBhCQADoDOllNFAERmHoCO7tC+Mat9egZyEwH9ftM9Ex7YudotTFR1NuW+5hVaPcAvLy2tY+2p9aLgAiIwOQS+MrVA9gSno9YoMwTNKMUPgOgeXseyRNDKYSaHXwfLUHXlx+Ga2hJqiQCIiACIiACIiACIiACk01AU+Anm7DyH0LgS798GDv7ZyOJJri+sDcX2A9ajPg6UIVN+ML5Lxqy/Uz58qnr7kVVug8ht4L+0szSz+WUwjgSgRhak/X41juPGRbFN37bidi2CBxa1SRpiePS/5oNRkOchhigNc4nL40Ou+90r/jajV3Y4najP+DAoejnS9M6Mu2npVAQ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Y8eOtYsb6Yr0GvjUWyDQ8xRJehwFAQT6L0AAtP9mHIEAAggggMCgCVx/yY/k7qf/T3Y3rxVxh8RtVn6PmTlBj5h0nHz8hI8P2nU4EQIIIIAAAggggMDABTSgOX36dHvTs2gAdMuWLTYrtK6uzg5b1yHsnZ2dEg6HbcBT5/LUooFQHTKvXzWwqUPpdTX3srIy0UxTneNTg6CDPazeXpz/EEDAChAA5RsBAQQQQACBERa4+p8/O8I14PIIIIAAAggggAAC/RHQuUD1pquyJ4oOZdcgqA5tDwaDNgiq2xLBTx3irqu36/yeGlClIIDA8AkQAB0+a66EAAIIIIAAAggggAACCCCAAAIOFUjMCerQ5tEsBDJagI8cMrr7qDwCCCCAAAIIIIAAAggggAACCCCAAAII9CZAALQ3HbYhgAACCCCAAAIIIIAAAggggAACCCCAQEYLEADN6O6j8ggggAACCCCAAAIIIIAAAggggAACCCDQmwAB0N502IYAAggggAACCCCAAAIIIIAAAggggAACGS1AADSju4/KI4AAAggggAACCCCAAAIIIIAAAggggEBvAgRAe9NhGwIIIIAAAggggAACCCCAAAIIIIAAAghktAAB0IzuPiqPAAIIIIAAAggggAACCCCAAAIIIIAAAr0JEADtTYdtCCCAAAIIIIAAAggggAACCCCAAAIIIJDRAgRAM7r7qDwCCCCAAAIIIIAAAggggAACCCCAAAII9CZAALQ3HbYhgAACCCCAAAIIIIAAAggggAACCCCAQEYLEADN6O6j8ggggAACCCCAAAIIIIAAAggggAACCCDQmwAB0N502IYAAggggAACCCCAAAIIIIAAAggggAACGS1AADSju4/KI4AAAggggAACCCCAAAIIIIAAAggggEBvAgRAe9NhGwIIIIAAAggggAACCCCAAAIIIIAAAghktAAB0IzuPiqPAAIIIIAAAggggAACCCCAAAIIIIAAAr0JEADtTYdtCCCAAAIIIIAAAggggAACCCCAAAIIIJDRAgRAM7r7qDwCCCCAAAIIIIAAAggggAACCCCAAAII9CZAALQ3HbYhgAACCCCAAAIIIIAAAggggAACCCCAQEYLEADN6O6j8ggggAACCCCAAAIIIIAAAggggAACCCDQm4C3t41sQwCBwRXY1tQh7zd0SjgWk4mFAZldWTC4F+Bs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6piWOTpk1KhRpU0eCdScgABozTWpChEgQIAAAQIECBAgQIAAgdoUyIV6cphzTuWS84BKqyeQsyLmVAQ55dHo0aNXrzC5CVSwgABoBTeOSyNAgAABAgQIECBAgAABAgRaCmy22WZFwC6HwUurJ5BzDWdQeeONN26a8331SpSbQGUKCIBWZru4KgIECBAgQIAAAQIECBAgQKANgVy0JhcLmzZtWht7beqMQBrmAsNbbrllZ7I5lkDVCQiAVl2TuWACBAgQIECAAAECBAgQIFC/AhmwyxW/e/bsGdmDUVo1gaVLl8b06dOLYLIA6KoZylU9AgKg1dNWrpQAAQIECBAgQIAAAQIECBBoFNh2222Lnot6ga76P4ecQiAXPxo7dmwMGjRo1QuSk0AVCAiAVkEjuUQCBAgQIECAAAECBAgQIEDg/wlkAHSDDTYoejAuXrz4/+3wrMMCr7/+eqy//vqxww47dDiPAwlUq4AAaLW2nOsmQIAAAQIECBAgQIAAAQJ1KjBw4MDYfvvtY9iwYfHGG2/UqcKqV3v27NmRgeNNN9206AG66iXJSaA6BARAq6OdXCUBAgQIECBAgAABAgQIECDQTGCPPfYo5gLNnoxLlixptsfTlQm88sorhV0aNjQ0rOxw+wlUvYAAaNU3oQoQIECAAAECBAgQIECAAIH6E1hnnXWKXqBDhw7VC7QTzf/uu+/G/Pnzi96f73nPezqR06EEqldAALR6286VEyBAgAABAgQIECBAgACBuhbYc889Y8yYMfHaa6/FokWL6tqio5V//vnnY/To0bH77rtHjx7CQh11c1x1C/iXXt3t5+oJECBAgAABAgQIECBAgEDdCgwfPjzGjx9fLObz4osv1q1DRys+bdq0Ysj71ltvbfGjjqI5riYEBEBrohlVggABAgQIECBAgAABAgQI1KfAPvvsE1tssUXkwj75I7UtkIsevfTSS7H55pvHgQceqPdn20y21qiAAGiNNqxqESBAgAABAgQIECBAgACBehDo169f7LfffsWcls8991wsXbq0Hqrd6Tq+8MILsd566xU9ZjfaaKNO55eBQDULCIBWc+u5dgIECBAgQIAAAQIECBAgQCC23XbbYkGkwYMHR85xKbUUePPNN2POnDkxbty4eP/7399yp1cE6kBAALQOGlkVCRAgQIAAAQIECBAgQIBArQsccsghkaua5yrnGfCT/ikwb968yPlRt9pqqzj00ENjwIABaAjUnYAAaN01uQoTIECAAAECBAgQIECAAIHaExg0aFB89KMfLQJ9GfCbO3du7VWykzVasmRJPPnkk7HJJpvEvvvuG2PGjOlkCQ4nUBsCAqC10Y5qQYAAAQIECBAgQIAAAQIE6l5g4403LgJ9m222WTzxxBOxYMGCujVZtmxZEfxce+21Y6eddooJEybUrYWKE+iFgAABAgQIECBAgAABAgQIECBQKwLvfe97Y8aMGbFo0aIiCJrzg/bqVX/hj6effjp69+4du+yySxx22GHR0NBQK02sHgQ6LaAHaKfJZCBAgAABAgQIECBAgAABAgQqWeDDH/5w7LbbbrHuuusWQdAcCl5PKReCWrx4cdHz88gjj4z+/fvXU/XVlUArAQHQViQ2ECBAgAABAgQIECBAgAABAtUs0KNHjzj88MNj/PjxMWTIkHj00UeLHqHVXKeOXHsOe3/mmWeK+U9z2PvRRx8dgwcP7khWxxCoaQEB0JpuXpUjQIAAAQIECBAgQIAAAQL1KdCnT5846qijYq+99orhw4fHpEmTanpO0KVLl8bkyZMjHzPwe8wxx8SwYcPqs/HVmsByAvU3CcZyAF4SIECAAAECBAgQIECAAAECtSnQr1+/+MQnPhH5+Pe//70Igo4bNy7WWmutmqrwwoULiwWPBg4cWMz5mXXOnq8SAQL/FBAA9S+BAAECBAgQIECAAAECBAgQqFmBXAAph8PnPJh33313ESgcOXJkbLjhhjVR55kzZxbD3keNGlXM+XnEEUfEgAEDaqJuKkGgqwQEQLtKUjkECBAgQIAAAQIECBAgQIBARQrknKAHH3xwjBgxIm655ZZiYaRZs2bF2LFji5XSK/KiV3JROd/nyy+/HG+99VZstdVWMWHChNh///3rcsX7lVDZTSAEQP0jIECAAAECBAgQIECAAAECBOpCIBcGyp6fv//974vh8I888kiMHj061l9//aqq/+zZs+O5554renruuuuukaveb7311lVVBxdLYE0KCICuSW3nIkCAAAECBAgQIECAAAECBLpVIIOdxx57bEycODEeeOCBePbZZ2Pq1Kmx2WabRc6hWclp0aJF8eKLL0YGQPN6t9122/jQhz4Ua6+9diVftmsj0O0CAqDd3gQugAABAgQIECBAgAABAgQIEFiTArlCfAYOt9tuu7j11luLIfG5gnoujrTRRhtV3ByaGficMmVKTJs2rRjGn4HP/fbbrwiArkk35yJQrQICoNXacq6bAAECBAgQIECAAAECBAgQWC2BXDgoe4M++OCDxQJJL730UhEMzZ6gua+7V4tfsGBBEfjMeT6z5+ouu+xS/Lzvfe8rVrZfrcrLTKCOBARA66ixVZUAAQIECBAgQIAAAQIECBBoKdDQ0BA5j+YOO+wQDz/8cNx///3xwgsvFEPjc6Gh9dZbL4YPHx59+/ZtmbFMr5YsWVIsbJS9PefPnx8bbLBB7LbbbrHzzjvH+PHjY/DgwWU6s2IJ1K6AAGjttq2aESBAgAABAgQIECBAgAABAh0U6N27dxFgzEDjpEmT4qGHHorsEfrmm28Wr/v161fMtZnzbXb1XKHZ03PmzJnx9ttvxzvvvBNDhw4thuKPHDmyCMzmNXX1OTvI4jACNSEgAFoTzagSBAgQIECAAAECBAgQIECAQFcI9OzZM3bcccfiJ+fdfPzxx+PJJ5+M119/PWbMmBHPPPNMZMBy0KBBRVAyA5PZOzQDpBlEzR6l7aXFixcXvTqzZ+e8efNizpw5RcCzR48eMWTIkKK36Xve854YO3Zssar75ptvHrlPIkBg9Zcn4A0AADaVSURBVAQEQFfPT24CBAgQIECAAAECBAgQIECgRgU23HDDyJ8DDjggXnvttWJofPYKzcBoBkMzgDlr1qymoGYGODNlELUUuFy6dGnkTw6nz+2lYGn//v2LgGcGOUeMGBGjR4+OTTfdtHjMQKpEgEDXCQiAdp2lkggQIECAAAECBAgQIECAAIEaFMhenaVg6IQJEyLn6cw5OnN4fC5QlMPXMxBa6tWZPUQz6JkpA6G9evUqeotm0DPn8Mzenuuuu24xt2gubrSm5hetwaZRJQIdEhAA7RCTgwgQIECAAAECBAgQIECAAAEC/xTInpzZazN/2krZ2zODpJny2BUNi28rv20ECHStgABo13oqjQABAgQIECBAgAABAgQIEKhzgQx4Zq9PiQCByhAwk25ltIOrIECAAAECBAgQIECAAAECBAgQIECgDAICoGVAVSQBAgQIECBAgAABAgQIECBAgAABApUhIABaGe3gKggQIECAAAECBAgQIECAAAECBAgQKIOAAGgZUBVJgAABAgQIECBAgAABAgQIECBAgEBlCAiAVkY7uAoCBAgQIECAAAECBAgQIECAAAECBMogIABaBlRFEiBAgAABAgQIECBAgAABAgQIECBQGQICoJXRDq6CAAECBAgQIECAAAECBAgQIECAAIEyCAiAlgFVkQQIECBAgAABAgQIECBAgAABAgQIVIaAAGhltIOrIECAAAECBAgQIECAAAECBAgQIECgDAICoGVAVSQBAgQIECBAgAABAgQIECBAgAABApUh0KsyLsNVECBAgAABAgQIECBAgAABAvUkMHTo0HqqrroSINCNAnqAdiO+UxMgQIAAAQIECBAgQIAAAQIECBAgUF4BAdDy+iqdAAECBAgQIECAAAECBAgQIECAAIFuFBAA7UZ8pyZAgAABAgQIECBAgAABAgQIECBAoLwCAqDl9VU6AQIECBAgQIAAAQIECBAgQIAAAQLdKCAA2o34Tk2AAAECBAgQIECAAAECBAgQIECAQHkFBEDL66t0AgQIECBAgAABAgQIECBAgAABAgS6UUAAtBvxnZoAAQIECBAgQIAAAQIECBAgQIAAgfIKCICW11fpBAgQIECAAAECBAgQIECAAAECBAh0o4AAaDfiOzUBAgQIECBAgAABAgQIECBAgAABAuUVEAAtr6/SCRAgQIAAAQIECBAgQIAAAQIECBDoRgEB0G7Ed2oCBAgQIECAAAECBAgQIECAAAECBMorIABaXl+lEyBAgAABAgQIECBAgAABAgQIECDQjQICoN2I79QECBAgQIAAAQIECBAgQIAAAQIECJRXQAC0vL5KJ0CAAAECBAgQIECAAAECBAgQIECgGwUEQLsR36kJECBAgAABAgQIECBAgAABAgQIECivgABoeX2VToAAAQIECBAgQIAAAQIECBAgQIBANwoIgHYjvlMTIECAAAECBAgQIECAAAECBAgQIFBeAQHQ8voqnQABAgQIECBAgAABAgQIECBAgACBbhQQAO1GfKcmQIAAAQIECBAgQIAAAQIECBAgQKC8AgKg5fVVOgECBAgQIECAAAECBAgQIECAAAEC3SggANqN+E5NgAABAgQIECBAgAABAgQIECBAgEB5BRqWNabynkLp7QksWbKkvV22d0CgZ8+ewbADUFVwSENDQ/To8c/vY5YuXRr+W6qCRlvJJZba1D26Eqgq2Z33Z7ZpJm1aJY22ksvM9syf/D9Xqn6B0j2a75/atPrbM2uQbZrt6TNRbbRn/t6SaU18zp0/f34MHDiwNuDUggABAl0o0KsLy1JUJwXmzp3byRwOLwnkh8J8Y1+wYIFfxksoVfzYp0+f6Nu3b1GDbNPFixdXcW1cegr07t07+vXrF/6fq41/D/37949evf75kWHevHl+Ia+BZs37M99L3aM10JiNVRg0aFBRkQyWadPaaNP8nJufh/JzkVTdAqXfW7IW+SViBiglAgQIEFjzAgKga9686Yzvvvtu03NPOieQ36LmB8P8RXzhwoWdy+zoihPIX9xKAdD8UOiDYcU1UacvaMCAAUUA1P9znaaryAz5JUUpADpnzhw9zCqylTp3Ufk+mm3qHu2cW6UeXQqAZu8ybVqprdS568ovnvIzrvbsnFslHp1fCpd6ZC5atKjsbZqfwSQCBAgQaC1gDtDWJrYQIECAAAECBAgQIECAAAECBAgQIFAjAgKgNdKQqkGAAAECBAgQIECAAAECBAgQIECAQGsBAdDWJrYQIECAAAECBAgQIECAAAECBAgQIFAjAgKgNdKQqkGAAAECBAgQIECAAAECBAgQIECAQGsBAdDWJrYQIECAAAECBAgQIECAAAECBAgQIFAjAgKgNdKQqkGAAAECBAgQIECAAAECBAgQIECAQGsBAdDWJrYQIECAAAECBAgQIECAAAECBAgQIFAjAgKgNdKQqkGAAAECBAgQIECAAAECBAgQIECAQGsBAdDWJrYQIECAAAECBAgQIECAAAECBAgQIFAjAr1qpB6qQaCuBX71fy6Mvd+aGsMXL40eS5fFoh4NMaVvz5i8y/bxoYM+Vdc2Kk+AAAECBAgQIECAAAECBAjUt4AAaH23v9rXgMAj5/1/8alZC6LP0oiGoj7//HvogiWx2V3/iJsmPRsHf/27NVBTVSBAgAABAgQIECBAgAABAgQIdF7AEPjOm8lBoGIE7vmP78RujcHPvo3Bz7yZlzbGPhc3/ixpfJ6vByyK+MjM2XHdf/2oYq7ZhRAgQIAAAQIECBAgQIAAAQIE1qSAHqBrUtu5CHSxwO6z3onejcHPTAubfZ2xrDEI2jgSPvo0/vRbHHHQlFf/eZC/CRAgQIAAAQIECBAgQIAAAQJ1JtAsZFJnNVddAlUu8Msfnh0DFzVEQ0NDND60Tv+3N2je5OvN/79R0tZH2UKAAAECBAgQIECAAAECBAgQqGkBAdCabl6Vq2WBzRfPbxzmviyWLWvs5tlWALSx8jkkPlOpl+g/X/mbAAECBAgQIECAAAECBAgQIFA/AobA109bq2mNCSzqkeHPdmOfTbXNHqISAQIECBAgQIAAAQIECBAgQKBeBfQArdeWV++qF3hn1LaxJO/gxgBnQ0ZC20i9GrdnD9E5+UQiQIAAAQIECBAgQIAAAQIECNShgABoHTa6KteGwEFHHRFv9m1oXOxoWfTO+OZyMc6GYmX4hljS2AH02UF9a6PSakGAAAECBAgQIECAAAECBAgQ6KSAAGgnwRxOoJIEfjt4aMzt3TjXZ+NF9WmcCLRX45OejT99Gn96NQY+lzQGR9/suyzGffP7lXTZroUAAQIECBAgQIAAAQIECBAgsMYEBEDXGLUTEeh6gWNP/rf41ZgNY3q/iMWNAc/sBJozfmavz0WNQ+NfGtQjBp31w64/sRIJECBAgAABAgQIECBAgAABAlUiYBGkKmkol0mgPYEjjz+12HX9+d+N7ZbOjb5LljbO+dkzHh62XpT2tZfXdgIECBAgQIAAAQIECBAgQIBArQsIgNZ6C6tf3Qh89JvfbVHXsS1eeUGAAAECBAgQIECAAAECBAgQqE8BQ+Drs93VmgABAgQIECBAgAABAgQIECBAgEBdCAiA1kUzqyQBAgQIECBAgAABAgQIECBAgACB+hQQAK3PdldrAgQIECBAgAABAgQIECBAgAABAnUhIABaF82skgQIECBAgAABAgQIECBAgAABAgTqU0AAtD7bXa0JECBAgAABAgQIECBAgAABAgQI1IWAAGhdNLNKEiBAgAABAgQIECBAgAABAgQIEKhPAQHQ+mx3tSZAgAABAgQIECBAgAABAgQIECBQFwICoHXRzCpJgAABAgQIECBAgAABAgQIECBAoD4FBEDrs93VmgABAgQIECBAgAABAgQIECBAgEBdCAiA1kUzqyQBAgQIECBAgAABAgQIECBAgACB+hQQAK3PdldrAgQIECBAgAABAgQIECBAgAABAnUhIABaF82skgQIECBAgAABAgQIECBAgAABAgTqU0AAtD7bXa0JECBAgAABAgQIECBAgAABAgQI1IWAAGhdNLNKEiBAgAABAgQIECBAgAABAgQIEKhPAQHQ+mx3tSZAgAABAgQIECBAgAABAgQIECBQFwICoHXRzCpJgAABAgQIECBAgAABAgQIECBAoD4FBEDrs93VmgABAgQIECBAgAABAgQIECBAgEBdCAiA1kUzqyQBAgQIECBAgAABAgQIECBAgACB+hQQAK3PdldrAgQIECBAgAABAgQIECBAgAABAnUhIABaF82skgQIECBAgAABAgQIECBAgAABAgTqU0AAtD7bXa0JECBAgAABAgQIECBAgAABAgQI1IVAr7qopUoSqBOBK//zJ9GwtCGW9Y44/rgv10mtVZMAAQIECBAgQIAAAQIECBAg0L6AAGj7NvYQqBqBn17+k3h7rakxa+1ZsaTHkui9pHf86Bffi7XmDY/PnfDFqqmHCyVAgAABAgQIECBAgAABAgQIdLWAIfBdLao8AmtY4KdX/jheXOeZeGbo8zF9wIx4t8/ceGPQm/HM2s/Fa43brrz8kjV8RU5HgAABAgQIECBAgAABAgQIEKgcAQHQymkLV0Kg0wL/edmP45XBLzUGPN+KYXOHxsh314/15g6Ljd4ZEf0X9Y0pA9+IGYPeiD/f+sdOly0DAQIECBAgQIAAAQIECBAgQKAWBARAa6EV1aFuBRp6LYpZfWfF4PkDY8CS/i0chiwcHD2W9YgZ/WbGG8+/3GKfFwQIECBAgAABAgQIECBAgACBehEQAK2XllbPmhRY0Ht+zOu1oLG3Z7826zewcfv8ngtiac/Fbe63kQABAgQIECBAgAABAgQIECBQ6wICoLXewupX0wI9ovHPssZV33ssa7OeyxqWRUPjnzxGIkCAAAECBAgQIECAAAECBAjUo4AAaD22ujrXjEC/RY1D3xf1b1z4aE6rOi2NZTG7cUGk3L90cc9W+20gQIAAAQIECBAgQIAAAQIECNSDgABoPbSyOtauQMPSWGf+2o3D3BfF231nxtLGP5kWNSyOaQOnR//FfWL4vOFx/JdOrF0DNSNAgAABAgQIECBAgAABAgQIrEBAAHQFOHYRqHSBzx33tVhv1obFqu9LG4fBvzLkjXhx8JR4fa03i1XgR78zKvotXrvSq+H6CBAgQIAAAQIECBAgQIAAAQJlE+hVtpIVTIDAGhE47otficsuuzjWnT88ZvWZGYt6Loy+jYsfDV04LHr06B2f+9yX18h1OAkBAgQIECBAgAABAgQIECBAoBIFBEArsVVcE4FOCnzxi1/tZA6HEyBAgAABAgQIECBAgAABAgTqQ8AQ+PpoZ7UkQIAAAQIECBAgQIAAAQIECBAgUJcCAqB12ewqTYAAAQIECBAgQIAAAQIECBAgQKA+BARA66Od1ZIAAQIECBAgQIAAAQIECBAgQIBAXQoIgNZls6s0AQIECBAgQIAAAQIECBAgQIAAgfoQEACtj3ZWSwIECBAgQIAAAQIECBAgQIAAAQJ1KSAAWpfNrtIECBAgQIAAAQIECBAgQIAAAQIE6kNAALQ+2lktCRAgQIAAAQIECBAgQIAAAQIECNSlgABoXTa7ShMgQIAAAQIECBAgQIAAAQIECBCoDwEB0PpoZ7UkQIAAAQIECBAgQIAAAQIECBAgUJcCAqB12ewqTYAAAQIECBAgQIAAAQIECBAgQKA+BARA66Od1ZIAAQIECBAgQIAAAQIECBAgQIBAXQoIgNZls6s0AQIECBAgQIAAAQIECBAgQIAAgfoQEACtj3ZWSwIECBAgQIAAAQIECBAgQIAAAQJ1KSAAWpfNrtIECBAgQIAAAQIECBAgQIAAAQIE6kNAALQ+2lktCRAgQIAAAQIECBAgQIAAAQIECNSlgABoXTa7ShMgQIAAAQIECBAgQIAAAQIECBCoDwEB0PpoZ7UkQIAAAQIECBAgQIAAAQIECBAgUJcCAqB12ewqTYAAAQIECBAgQIAAAQIECBAgQKA+BARA66Od1ZIAAQIECBAgQIAAAQIECBAgQIBAXQoIgNZls6s0AQIECBAgQIAAAQIECBAgQIAAgfoQ6FVr1Zw+fXrccMMN8dxzz8XUqVNjvfXWi0022SSOOuqoGD58eKeqe/vtt8ekSZPazbPuuuvGMccc0+5+OwgQIECAAAECBAgQIECAAAECBAgQ6F6BmgqA/u1vf4tzzz035s2bFz179oxhw4bFQw89FA888ED88Y9/jG9+85ux3377dVj8D3/4Q5G/vQybbrqpAGh7OLYTIECAAAECBAgQIECAAAECBAgQqACBmgmATpkypSn4eeyxxxaByb59+8aCBQviF7/4RfFz3nnnxRZbbBEbbbRRh+ifeeaZ4riTTjopsqzl01prrbX8Jq8JECBAgAABAgQIECBAgAABAgQIEKgggZoJgN50001Fz8/9998/PvvZzzYRZ+Dy+OOPj5dffjmyh2ge96Uvfalpf3tPpk2bFrNnzy56kR5xxBHtHWY7AQIECBAgQIAAAQIECBAgQIAAAQIVLFAziyA9/PDDBfN73/veNrl32223Yvuzzz7b5v7lN5Z6f2655ZbL7/KaAAECBAgQIECAAAECBAgQIECAAIEqEaiZHqA//vGPIxdAGjp0aJv0b7/9drG9vf3LZ1o+ALp48eKiR+g666yz/KFeEyBAgAABAgQIECBAgAABAgQIECBQoQI1EwDNoe4jR45skzmDlzfffHOxb5tttmnzmOU3lgKgmffkk0+O7GG6ZMmSyHk/d91118h5QXORpRWlzHPXXXe1eciQIUPi8MMPb3OfjSsX6NHjn52X+/fvH3369Fl5BkdUtEDzNuzXr1/06lUz/zVVtHs5L653795F8YMGDSrnaZS9hgRyYcFSGjhwYCxbtqz00mOVCuQ9mu+l7tEqbcB2LlubtgNThZuzLfPzkXu0ChtvuUsu/d6Sm/P/Xm26HJCXBAgQWEMCDY2/xNT8bzGXXnppXH/99bHhhhvGz372s8gAy8rSUUcdFa+99lpxWP7iN27cuMhg6PPPPx+LFi2KwYMHx8UXXxybb755u0VdffXVkQsvtZVyIaaJEye2tcs2AgQIECBAgAABAgQIECDQaYG5c+fGgAEDOp1PBgIECNS6QM13s8rAZ/7kN29nnHFGh4Kfc+bMaQp+HnTQQXHqqadG9jTMlEHRs846K5544oli1fkrrrhCb7Vav0vUjwABAgQIECBAgAABAgQIECBAoGoFaroHaAYnr7nmmiL4+e1vfzsOOOCADjXU0qVLY8qUKfHWW2/FDjvsEA0NDS3yTZ06NY455phYsGBBnH/++bHnnnu22F968cILL8TkyZNLL1s85hDC7bbbrsU2LzoukAHtnEbgnXfeKXrmdjynIytRIHtll75kyC8gFi5cWImX6Zo6IZDTkmTvgxkzZnQil0MrVSCH65WmNZg5c6Yh8JXaUJ24rrw/c4RLvo9K1S+Qc9zn59Wcrmn27NnVXyE1KEab5aizefPm0ahygfy/NkcPZsrfH7OHZjlT8/OV8zzKJkCAQLUJ1GQP0PywkEPPb7311mLunDPPPDP23nvvDrdNBtdyiHr+tJXWX3/92HbbbePBBx8shsS3FwDdZJNNIn/aS6+//np7u2xfiUC+sWfKQJlg2UqwqmB38zk/sz3nz59fBVftElckUJrvSluuSKl69jUfSpe/vOUXhVJ1C+SXFBkwc49Wdzsuf/U5s5U2XV6lOl/nugM5/Zb2rM72a37VpS8Qc1t+SVHuNm3+nt38OjwnQIBAvQvUXAA0ezJ861vfKhYtym/aMhCawcquTuutt15RZK48LxEgQIAAAQIECBAgQIAAAQIECBAgUJkCNRUAzSE/uTr7c889F6NGjYoLLrig3V6cK2qOp556Ku67775i+OYRRxzR5qHTpk0rtud5JAIECBAgQIAAAQIECBAgQIAAAQIEKlOgZgKgOeTn9NNPL4KfW265ZfzgBz8o5ohcFfacs+6qq64qhoaNHz8+xowZ06KYt99+Ox5//PFi2zbbbNNiX2dejBgxojOHO7YNgWHDhrWx1aZqE7j88svjJz/5SXHZOa/uwQcfXG1VcL3tCPh/rh2YKtt8/PHHx7333ltc9cSJE0O7VlkDruByteUKcKpo10477VRMCTRy5MhiCqgqunSXugKBnH85f6TqFnjsscdin332KSrx4Q9/uBihWN01cvUECBCoToEe1XnZra/6pptuikcffTTWXXfduPDCCzsc/Lznnnvitttui1ywqJRy4aOcTD6Dqj/72c9aLLKTc7ZkgCYnJN9rr71i3LhxpWweCRBYRYGcDynn7s0fcwuuIqJsBMookPPQle7RfG+UCBCoLIHS/ZmPEgEClSWQn21L92h+5pUIECBAoHsEaqIHaC7IkD3IMuXK7Ycddli7mptvvnnRu7N0wMUXXxy5GFH2biktWJQrUn/nO9+JU045JbKny0MPPRQHHnhgsVrqnXfeGa+++mpx7Mknn1wqxiMBAgQIECBAgAABAgQIECBAgAABAhUoUBMB0Oy9mYsfldKKvlnLXiwdSbvssktcdtllkQHSyZMnx69+9asiW//+/eOggw4qgqNW2OuIpGMIECBAgAABAgQIECBAgAABAgQIdJ9ATQRAcxj6XXfdtUqKN9xwQ7v5cn7PK664ImbNmhWvvPJKrLXWWsWiSj161MzMAe3W3Q4CBAgQIECAAAECBAgQIECAAAECtSBQEwHQcjfEkCFDOjynaLmvRfkECBAgQIAAAQIECBAgQIAAAQIECHRcQFfGjls5kgABAgQIECBAgAABAgQIECBAgACBKhNoaFzN1XKuVdZoLpdArQk899xz8cwzzxTV2n777WPEiBG1VkX1IVDVAg8++GCxyGBWYp999olcLFAiQKByBG677bbIOfBzrvq99967ci7MlRAgUEyndu+99xYSI0eOjO22244KAQIECHSDgABoN6A7JQECBAgQIECAAAECBAgQIECAAAECa0bAEPg14+wsBAgQIECAAAECBAgQIECAAAECBAh0g4AAaDegOyUBAgQIECBAgAABAgQIECBAgAABAmtGQAB0zTg7CwECBAgQIECAAAECBAgQIECAAAEC3SAgANoN6E5JgAABAgQIECBAgAABAgQIECBAgMCaEei1Zk7jLAQI1LPAxIkT429/+1u8+uqrxQrv2267bbz//e9f4WrvTz75ZNx4443x0ksvxcCBAyPz7LvvvrHpppvWM6W6EyiLwIwZM+KPf/xjPPXUUzFlypTYYIMNYvfdd4+PfOQj0atX2x8V3KNlaQqFEmgl8Pbbb8cNN9wQTz/9dEyfPj023HDDOOCAA4rV3nv0aLsvw4IFC+LXv/51PPjgg5H399ixY2OHHXaID3zgA9GzZ89W57CBAIHOCfz5z3+OX/ziF/Hd7343ttpqq3Yz33777XHXXXcVn4GXLl0ao0ePjj322KO4h9vL5P21PRnbCRAgsHoCVoFfPT+5CRBYgcDixYvj9NNPj/vvv784aq211op33303li1bFkOGDIkLLrggtt5661Yl5C9tF198cbF90KBBsXDhwuKnf//+cd5558VOO+3UKo8NBAismsDjjz8e//Zv/xZvvvlmNDQ0xLBhw+Ktt94qCstf6i655JLo27dvi8Ldoy04vCBQNoH77rsvzj777Jg1a1ZxjnXXXbfp/tx///3jO9/5Tqtzz5w5M770pS/FK6+8UuxbZ511IoOomd73vvcVefr06VO89hcBAp0XePTRR+Okk06K/Jyb75H55cLyKb+E+PrXvx4PP/xwsWvw4MHF4+zZs4vHzJOfg/OzbfPk/bW5hucECBDoWoG2vzbu2nMojQCBOhX4z//8zyL4OXLkyDjnnHOKHma/+c1v4tOf/nTxy9xXv/rVojdLc578UPnjH/848pezzPOXv/wlbrnlluKD5rx58+K0006LN954o3kWzwkQWEWB/EXs5JNPLoKfRx11VPzhD3+I3/3ud3HttdfGmDFjYvLkyXHZZZe1KN092oLDCwJlE8ig5VlnnVW8X+6zzz5x0003Fffnn/70p6L3Z46uyHt1+fTv//7vRfBzt912izw27+vrr78+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1RcQAF19QyUQILACgaeeeqpY7TKDKaWUHwZzmN6JJ54YbS1mVPrm/NZbby3mAs18meewww6LE044oUVvtFKZHgkQWDWB/IXrpz/9adHLLKefyJQrw++0007xta99rWlxsualu0eba3hOoHwCORXFZZddFn/605+K3mR5phxSm4HNXFW6+ReIza8i5wfNLwtLC5jlvuwZevLJJxf3dvNjPSdAoPMCKwqAfuMb3yi+cOhIqeecc068733vazrU+2sThScECBDocgEB0C4nVSABAm0JzJgxI15++eUYOHBgjB49OnJl25Wl7PmZ84RmR/WNNtqoyLuyPPYTILBqAnmfTZkypRj2nj3GcrGxlSX36MqE7CfQNQI5HUW+h5beD/NLio6kHDmRi6rkfL+5WnxH7uuOlOsYAgTKK+D9tby+SidAoD4FBEDrs93VmgABAgQIECBAgAABAgQIECBAgEBdCKy8e0ddMKgkAQIECBAgQIAAAQIECBAgQIAAAQK1KCAAWoutqk4ECBAgQIAAAQIECBAgQIAAAQIECBQCAqD+IRAgQIAAAQIECBAgQIAAAQIECBAgULMCAqA127QqRoAAAQIECBAgQIAAAQIECBAgQICAAKh/AwQIECBAgAABAgQIECBAgAABAgQI1KyAAGjNNq2KESBAgAABAgQIECBAgAABAgQIECAgAOrfAAECBAgQIECAAAECBAgQIECAAAECNSsgAFqzTatiBAgQIECAAAECBAgQIECAAAECBAgIgPo3QIAAAQIECBAgQIAAAQIECBAgQIBAzQoIgNZs06oYAQIECBAgQIAAAQIECBAgQIAAAQK9EBAgQIAAAQIEukpgyZIl8dRTT8UzzzwTm222WWy55ZbRu3fvripeOQQIECBAgAABAgQIEOi0gB6gnSaTgQABAgQIEGguMHv27DjjjDNi1113jUGDBsU222wThx56aGy77bbF6x133DFOOOGEePHFF5tna/H8tNNOi4aGhuJn4cKFLfZ5QYAAAQIECBAgQIAAgdUR0AN0dfTkJUCAAAECdS7w+OOPx3777RdTp05tUyKDmY888kjxc80118SVV14ZxxxzTKtjly1b1mqbDQQIECBAgAABAgQIEOgKAT1Au0JRGQQIECBAoA4FsufnQQcd1BT8nDBhQlx33XVx//33F709H3roobjxxhuLY5Jn3rx58ZnPfCZuv/32Vlo5TL5fv37FT6udNhAgQIAAAQIECBAgQGA1BBoae1zocrEagLISIECAAIF6FTj//PPj9NNPL6r/9a9/PS644IJ2KS699NI48cQTi/05VP6BBx5o91g7CBAgQIAAAQIECBAg0JUCAqBdqaksAgQIECBQRwL77rtv0Ztz4MCBMWPGjJUudnTAAQfExIkTC6HJkyfHuHHj6khLVQkQIECAAAECBAgQ6C4Bc4B2l7zzEiBAgACBKhd46623ihpssMEGKw1+5oGHHHJIEQDt1atXPP300y0CoK+88kq8/vrrRXnZQzQXRMo0adKkmD9/fvG8I3+tv/76MWbMmFaH5oCXXJn+f//3fyPnLR05cmTssMMOxUJN/fv3b3W8DQQIECBAgAABAgQI1I6AHqC105ZqQoAAAQIE1qhADmnPoe0ZrMz5PnO19xWlBQsWFMHMIUOGtDrs1FNPjYsuuqjYnsf16dOneL7FFlsUgctWGdrZkNd0ySWXtNj77LPPxqc+9alibtIWOxpfrLfeevHTn/40PvzhDy+/y2sCBAgQIECAAAECBGpEwCJINdKQqkGAAAECBNa0wAc/+MHilNm7MhdD+tGPfhTvvPNOu5fRt2/faCv42W6Gxh3ZU3P06NGtfjbeeOPYcsstY/vtt2+xcNKoUaNaFPfb3/626OmZCzNloHb8+PFx7LHHxv777x+DBw+OadOmxUc+8pH45je/2SKfFwQIECBAgAABAgQI1I6AHqC105ZqQoAAAQIE1qjAkiVL4otf/GJceeWVTefN1dz32GOPOPDAA2O//faLXXbZJXLI+8pSez1AV5bv2muvjU9/+tPFYQcffHD84Q9/iJ49exavc17SsWPHxvTp02OjjTaKa665Jvbee++mInP70UcfHbfddlux7e6774699tqrab8nBAgQIECAAAECBAjUhoAeoLXRjmpBgAABAgTWuEAGGq+44oo455xzmubsXLRoUdx5553x7W9/uwiErr322vGhD32oGGY+c+bMLr3G22+/PT73uc8VZWZP0Ouvv74p+JkbzzzzzCL42aNHj2Jf8+Bn7h82bFj85S9/KXqS5uuTTjopli5dmk8lAgQIECBAgAABAgRqSEAAtIYaU1UIECBAgEB3CJxxxhnFwkKnnHJKbL755i0u4d13342bb745jjvuuMhh6zk/Z1cEGZ944ok4/PDDY+HChTFixIi46aabYtCgQU3nzt6ppZ6pOVR/zz33bNrX/En2Ts3AZ6Z//OMf8dhjjzXf7TkBAgQIECBAgAABAjUgIABaA42oCgQIECBAoLsFttpqq/jBD35QLFj0/PPPFz1Dc3h5rhBfSrNmzSqCjSeccEJp0yo9vvHGG0Wv0uxROmDAgCL4mUPcm6eXX345cjGlTNk7NIfDt/eTCy2VUq4ULxEgQIAAAQIECBAgUFsCAqC11Z5qQ4AAAQIEul1gk002ieOPPz7++7//O1577bW47777ikWHShd21VVXFftKrzvzOGfOnGLF9pdeeilyaPt1110XO++8c6sinn766aZt5557bqyzzjrt/hxwwAFNxwqANlF4QoAAAQIECBAgQKBmBARAa6YpVYQAAQIECFSeQK68vttuuxULDeUq8aWUQ+E7m3JY+yc+8Yl46KGHiqznn39+HHrooW0W8+qrr7a5fWUbX3nllZUdYj8BAgQIECBAgAABAlUmIABaZQ3mcgkQIECAQCUInH322cXiQdmzcsqUKR26pK985StNQ+JXZa7NzP+nP/2pONfnP//5OO2009o976hRo5r2/eIXv4jZs2d36Oeiiy5qyucJAQIECBAgQIAAAQK1IdCrNqqhFgQIECBAgMCaFigNM//Nb37TtJDQiq4hh6xvvfXWkXN4Zm/OZcuWNa0ev6J8ue/CCy+Myy67rDgsh6xfeumlK8wyduzYpv1PPfVUrLXWWk2vPSFAgAABAgQIECBAoL4E9ACtr/ZWWwIECBAg0CUCe++9d1M5P//5z2PevHlNr9t7kosW3XXXXcXucePGdTj4eeONN8Y3v/nNIl8GUPN1rt6+opQrzvfr16845M9//vMKV57P8nKhpI9+9KNx9913r6hY+wgQIECAAAECBAgQqEIBAdAqbDSXTIAAAQIEulvgve99b+y+++7FZfzjH/+IPfbYI5599tl2L2vq1KmRq8IvWrSoOOa4445r99jmO+655574l3/5l6K36IgRI+Ivf/lLDBkypPkhbT7P3qZf/epXi32PPPJIU+/R5Q9+991348wzz4xJkybFrbfeGhmYlQgQIECAAAECBAgQqC2BhsbhZ8tqq0pqQ4AAAQIECKwJgccffzwmTJgQ2bMzUwYmDz744Nhpp51ixx13jKFDh8YTTzwROd/n1VdfHdOmTSuOGz9+fNxxxx1NPTRz46mnnhql+TcXLFgQffr0KQKqGWSdPn16cewNN9wQm2++ecydO7cpkFoUuNxfWX4GQDO4mQHNnKO0Z8+eRS/SM844IwYOHBh5jr/+9a/x/e9/v6lX6imnnBI/+MEPlivNSwIECBAgQIAAAQIEql1AALTaW9D1EyBAgACBbhTIHprZs7Ojq6dncDIXMho+fHiLq24rAJorxZ900kktjuvIiwyQ9u/fvzg0h7R/8pOfbLq+DIzm/KAZFM0AaSkdfvjhkQHWDJRKBAgQIECAAAECBAjUloAh8LXVnmpDgAABAgTWqMBee+0VkydPju9973ux3XbbtXvunXfeOS6//PK49957WwU/283UBTuyh2r2QD3++ONj8ODBxVyguShSKfi5ySabxJVXXhm/+tWvBD+7wFsRBAgQIECAAAECBCpRQA/QSmwV10SAAAECBKpUIFd4f+mll+Ktt94qFkZaf/31Y7PNNouRI0dWRI2yp2oO3c8FkjbddNMYNWpUMVy+Ii7ORRAgQIAAAQIECBAgUBYBAdCysCqUAAECBAgQIECAAAECBAgQIECAAIFKEDAEvhJawTUQIECAAAECBAgQIECAAAECBAgQIFAWAQHQsrAqlAABAgQIECBAgAABAgQIECBAgACBShAQAK2EVnANBAgQIECAAAECBAgQIECAAAECBAiURUAAtCysCiVAgAABAgQIECBAgAABAgQIECBAoBIEBEAroRVcAwECBAgQIECAAAECBAgQIECAAAECZREQAC0Lq0IJECBAgAABAgQIECBAgAABAgQIEKgEAQHQSmgF10CAAAECBAgQIECAAAECBAgQIECAQFkEBEDLwqpQAgQIECBAgAABAgQIECBAgAABAgQqQUAAtBJawTUQIECAAAECBAgQIECAAAECBAgQIFAWAQHQsrAqlAABAgQIECBAgAABAgQIECBAgACBShAQAK2EVnANBAgQIECAAAECBAgQIECAAAECBAiURUAAtCysCiVAgAABAgQIECBAgAABAgQIECBAoBIEBEAroRVcAwECBAgQIECAAAECBAgQIECAAAECZREQAC0Lq0IJECBAgAABAgQIECBAgAABAgQIEKgEAQHQSmgF10CAAAECBAgQIECAAAECBAgQIECAQFkEBEDLwqpQAgQIECBAgAABAgQIECBAgAABAgQqQUAAtBJawTUQIECAAAECBAgQIECAAAECBAgQIFAWAQHQsrAqlAABAgQIECBAgAABAgQIECBAgACBShD4/wF1LuIytB8pKgAAAABJRU5ErkJggg==" width="672" /></p>
<p>The graph provided above gives an indication of the link between the size of the app and its rating, with most apps having ratings above 4 and sizes below 100M. I would, therefore, suggest an app with a size below 100M. The graph also shows that, while most apps are linked to positive reviewer sentiment, there does not seem to be a link between reviewer sentiment and the number of installations. This can show that, even though it is important to listen to what reviews have to say, this does not necessarily correlate with how many people choose to install an app. If profitability is linked to the number of installations, it would be a better idea to focus on the app rating and keeping those numbers high while also ensuring that apps are not too big in size.</p>
</div>
<div id="app-ratings-and-categories" class="section level1" number="2">
<h1><span class="header-section-number">2</span> App ratings and categories</h1>
<table class="table" style="font-size: 10px; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:unnamed-chunk-2">Table 2.1: </span>Top 20 Rated Apps
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:left;">
App
</th>
<th style="text-align:left;">
Category
</th>
<th style="text-align:right;">
Rating
</th>
<th style="text-align:right;">
Installs
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
1
</td>
<td style="text-align:left;">
CDL Practice Test 2018 Edition
</td>
<td style="text-align:left;">
AUTO_AND_VEHICLES
</td>
<td style="text-align:right;">
4.9
</td>
<td style="text-align:right;">
100
</td>
</tr>
<tr>
<td style="text-align:left;">
2
</td>
<td style="text-align:left;">
DMV Permit Practice Test 2018 Edition
</td>
<td style="text-align:left;">
AUTO_AND_VEHICLES
</td>
<td style="text-align:right;">
4.9
</td>
<td style="text-align:right;">
100
</td>
</tr>
<tr>
<td style="text-align:left;">
3
</td>
<td style="text-align:left;">
Down Dog: Great Yoga Anywhere
</td>
<td style="text-align:left;">
HEALTH_AND_FITNESS
</td>
<td style="text-align:right;">
4.9
</td>
<td style="text-align:right;">
500
</td>
</tr>
<tr>
<td style="text-align:left;">
4
</td>
<td style="text-align:left;">
Amino: Communities and Chats
</td>
<td style="text-align:left;">
SOCIAL
</td>
<td style="text-align:right;">
4.8
</td>
<td style="text-align:right;">
10000
</td>
</tr>
<tr>
<td style="text-align:left;">
5
</td>
<td style="text-align:left;">
Calculator with Percent (Free)
</td>
<td style="text-align:left;">
TOOLS
</td>
<td style="text-align:right;">
4.8
</td>
<td style="text-align:right;">
1000
</td>
</tr>
<tr>
<td style="text-align:left;">
6
</td>
<td style="text-align:left;">
DU Recorder – Screen Recorder, Video Editor, Live
</td>
<td style="text-align:left;">
VIDEO_PLAYERS
</td>
<td style="text-align:right;">
4.8
</td>
<td style="text-align:right;">
50000
</td>
</tr>
<tr>
<td style="text-align:left;">
7
</td>
<td style="text-align:left;">
Even - organize your money, get paid early
</td>
<td style="text-align:left;">
FINANCE
</td>
<td style="text-align:right;">
4.8
</td>
<td style="text-align:right;">
100
</td>
</tr>
<tr>
<td style="text-align:left;">
8
</td>
<td style="text-align:left;">
Find a Way: Addictive Puzzle
</td>
<td style="text-align:left;">
FAMILY
</td>
<td style="text-align:right;">
4.8
</td>
<td style="text-align:right;">
500
</td>
</tr>
<tr>
<td style="text-align:left;">
9
</td>
<td style="text-align:left;">
FreePrints – Free Photos Delivered
</td>
<td style="text-align:left;">
PHOTOGRAPHY
</td>
<td style="text-align:right;">
4.8
</td>
<td style="text-align:right;">
1000
</td>
</tr>
<tr>
<td style="text-align:left;">
10
</td>
<td style="text-align:left;">
Fuzzy Seasons: Animal Forest
</td>
<td style="text-align:left;">
FAMILY
</td>
<td style="text-align:right;">
4.8
</td>
<td style="text-align:right;">
100
</td>
</tr>
<tr>
<td style="text-align:left;">
11
</td>
<td style="text-align:left;">
GoodRx Drug Prices and Coupons
</td>
<td style="text-align:left;">
MEDICAL
</td>
<td style="text-align:right;">
4.8
</td>
<td style="text-align:right;">
1000
</td>
</tr>
<tr>
<td style="text-align:left;">
12
</td>
<td style="text-align:left;">
GPS Speedometer and Odometer
</td>
<td style="text-align:left;">
MAPS_AND_NAVIGATION
</td>
<td style="text-align:right;">
4.8
</td>
<td style="text-align:right;">
1000
</td>
</tr>
<tr>
<td style="text-align:left;">
13
</td>
<td style="text-align:left;">
Home Workout - No Equipment
</td>
<td style="text-align:left;">
HEALTH_AND_FITNESS
</td>
<td style="text-align:right;">
4.8
</td>
<td style="text-align:right;">
10000
</td>
</tr>
<tr>
<td style="text-align:left;">
14
</td>
<td style="text-align:left;">
Home Workout for Men - Bodybuilding
</td>
<td style="text-align:left;">
HEALTH_AND_FITNESS
</td>
<td style="text-align:right;">
4.8
</td>
<td style="text-align:right;">
1000
</td>
</tr>
<tr>
<td style="text-align:left;">
15
</td>
<td style="text-align:left;">
1800 Contacts - Lens Store
</td>
<td style="text-align:left;">
MEDICAL
</td>
<td style="text-align:right;">
4.7
</td>
<td style="text-align:right;">
1000
</td>
</tr>
<tr>
<td style="text-align:left;">
16
</td>
<td style="text-align:left;">
Abs Training-Burn belly fat
</td>
<td style="text-align:left;">
HEALTH_AND_FITNESS
</td>
<td style="text-align:right;">
4.7
</td>
<td style="text-align:right;">
100
</td>
</tr>
<tr>
<td style="text-align:left;">
17
</td>
<td style="text-align:left;">
Ada - Your Health Guide
</td>
<td style="text-align:left;">
MEDICAL
</td>
<td style="text-align:right;">
4.7
</td>
<td style="text-align:right;">
1000
</td>
</tr>
<tr>
<td style="text-align:left;">
18
</td>
<td style="text-align:left;">
ASOS
</td>
<td style="text-align:left;">
SHOPPING
</td>
<td style="text-align:right;">
4.7
</td>
<td style="text-align:right;">
10000
</td>
</tr>
<tr>
<td style="text-align:left;">
19
</td>
<td style="text-align:left;">
Associated Credit Union Mobile
</td>
<td style="text-align:left;">
FINANCE
</td>
<td style="text-align:right;">
4.7
</td>
<td style="text-align:right;">
50
</td>
</tr>
<tr>
<td style="text-align:left;">
20
</td>
<td style="text-align:left;">
Backgrounds (HD Wallpapers)
</td>
<td style="text-align:left;">
PERSONALIZATION
</td>
<td style="text-align:right;">
4.7
</td>
<td style="text-align:right;">
10000
</td>
</tr>
</tbody>
</table>
<p>This table shows the categories that the top 20 highest rated apps fall into. There are quite a variety of categories in the top 20 but many of the categories are linked to ways that help people, whether this is with health, navigation, mathematics or practising for a written driving test. I would thus suggest creating an app that offers a helpful service, maybe linked to the health and fitness category. The top 20 apps also have a similar number of installations which suggests this is the range to aim for.</p>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
